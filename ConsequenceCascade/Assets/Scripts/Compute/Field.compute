#pragma kernel InitializeField  
#pragma kernel UpdateField  

#define PI 3.1415926

struct FieldCell {  
    float2 position;
    float2 previousPosition;
    float siderealTime;
    float precessionalTime;
    float mass;
};

struct SpaceTime {  
    float2 position;
    float2 previousPosition;
    float siderealTime;
    float precessionalTime;
    float mass;
};

float deltaTime;
float damping;
int width;  
int height;
float density;

float baseSemiMajorAxis;
float baseEccentricity;
float precessionalSpeed;
float siderealSpeed;
int iterations;
float siderealOffset;
float precessionalOffset;

RWStructuredBuffer<FieldCell> currentField;


[numthreads(8,8,1)]  
void InitializeField(uint3 id : SV_DispatchThreadID) {  
    if (id.x >= (uint)width || id.y >= (uint)height) return;  
    
    const uint index = id.y * width + id.x;  

    FieldCell cell;  
    cell.position = float2(0, 0);  
    cell.siderealTime = siderealOffset;
    cell.precessionalTime = precessionalSpeed;
    cell.previousPosition = cell.position;
    cell.mass = 0;
    currentField[index] = cell;  
}


float3 calculateEllipticOrbit(float axis, float timeParameter, float2 centerPosition, float rotationAngle)  
{  
    // Ensure eccentricity is valid  
    //baseEccentricity = clamp(baseEccentricity * baseEccentricity, 0.0, 0.9999);  
    
    // Semi-minor axis  
    const float semiMinorAxis = axis * sqrt(1.0 - baseEccentricity * baseEccentricity);  
    
    // Calculate mean anomaly (0-2Ï€)  
    float meanAnomaly = timeParameter * 2.0 * 3.14159265;  
    
    // Solve Kepler's equation to get eccentric anomaly  
    // M = E - e * sin(E)  
    // Using a simpler approximation
    float E = meanAnomaly;  
    
    // Newton-Raphson iterations (can adjust number of iterations for accuracy vs. performance)  
    for (int i = 0; i < 5; i++)  
    {  
        E = E - (E - baseEccentricity * sin(E) - meanAnomaly) / (1.0 - baseEccentricity * cos(E));  
    }  

    float xPos = axis * (cos(E) - baseEccentricity);  
    float yPos = semiMinorAxis * sin(E);  
    
    // Apply rotation  
    if (abs(rotationAngle) > 0.001)  
    {  
        float cosRot = cos(rotationAngle);  
        float sinRot = sin(rotationAngle);  
        float xRot = xPos * cosRot - yPos * sinRot;  
        float yRot = xPos * sinRot + yPos * cosRot;  
        xPos = xRot;  
        yPos = yRot;  
    }  
    
    // Apply translation to center  
    return float3(xPos, yPos, E);  
}  

[numthreads(8,8,1)]  
void UpdateField(uint3 id : SV_DispatchThreadID) {  
    if (id.x >= (uint)width || id.y >= (uint)height) return;
    
    const uint index = id.y * width + id.x;  
    FieldCell cell = currentField[index];
    const float2 gridPoint = float2(id.x, id.y);
   
    const float distanceToSun = length(float2((float)height * 0.5, (float)width * 0.5) - gridPoint);
    float3 orbit = calculateEllipticOrbit(baseSemiMajorAxis, cell.siderealTime, gridPoint * density, cell.precessionalTime);
    cell.position = gridPoint * density + float2(orbit.x, orbit.y);
    cell.siderealTime += (deltaTime * siderealSpeed / (distanceToSun)) * damping;
    cell.precessionalTime += (deltaTime * precessionalSpeed * (distanceToSun)) * damping;
    
    cell.previousPosition = cell.position;
    
    cell.mass = (orbit.z - (PI)) * 0.0001;
    currentField[index] = cell;  
}
